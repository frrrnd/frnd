---
import Grid from '../components/utils/Grid.astro';
import Top from '@components/utils/toTop.astro';
---

<Top />

<footer class="footer">
  <div class="blur-container"><!--$--><div style="position:absolute;inset:0;overflow:hidden"><div style="opacity: 1; position: absolute; inset: 0px; z-index: 1; mask-image: linear-gradient(rgba(0, 0, 0, 0) 0%, rgb(0, 0, 0) 12.5%, rgb(0, 0, 0) 25%, rgba(0, 0, 0, 0) 37.5%); border-radius: 0px; pointer-events: none; backdrop-filter: blur(0.078125px); will-change: auto;"></div><div style="opacity: 1; position: absolute; inset: 0px; z-index: 2; mask-image: linear-gradient(rgba(0, 0, 0, 0) 12.5%, rgb(0, 0, 0) 25%, rgb(0, 0, 0) 37.5%, rgba(0, 0, 0, 0) 50%); border-radius: 0px; pointer-events: none; backdrop-filter: blur(0.15625px); will-change: auto;"></div><div style="opacity: 1; position: absolute; inset: 0px; z-index: 3; mask-image: linear-gradient(rgba(0, 0, 0, 0) 25%, rgb(0, 0, 0) 37.5%, rgb(0, 0, 0) 50%, rgba(0, 0, 0, 0) 62.5%); border-radius: 0px; pointer-events: none; backdrop-filter: blur(0.3125px); will-change: auto;"></div><div style="opacity: 1; position: absolute; inset: 0px; z-index: 4; mask-image: linear-gradient(rgba(0, 0, 0, 0) 37.5%, rgb(0, 0, 0) 50%, rgb(0, 0, 0) 62.5%, rgba(0, 0, 0, 0) 75%); border-radius: 0px; pointer-events: none; backdrop-filter: blur(0.625px); will-change: auto;"></div><div style="opacity: 1; position: absolute; inset: 0px; z-index: 5; mask-image: linear-gradient(rgba(0, 0, 0, 0) 50%, rgb(0, 0, 0) 62.5%, rgb(0, 0, 0) 75%, rgba(0, 0, 0, 0) 87.5%); border-radius: 0px; pointer-events: none; backdrop-filter: blur(1.25px); will-change: auto;"></div><div style="opacity: 1; position: absolute; inset: 0px; z-index: 6; mask-image: linear-gradient(rgba(0, 0, 0, 0) 62.5%, rgb(0, 0, 0) 75%, rgb(0, 0, 0) 87.5%, rgba(0, 0, 0, 0) 100%); border-radius: 0px; pointer-events: none; backdrop-filter: blur(2.5px); will-change: auto;"></div><div style="opacity: 1; position: absolute; inset: 0px; z-index: 7; mask-image: linear-gradient(rgba(0, 0, 0, 0) 75%, rgb(0, 0, 0) 87.5%, rgb(0, 0, 0) 100%); border-radius: 0px; pointer-events: none; backdrop-filter: blur(5px); will-change: auto;"></div><div style="opacity: 1; position: absolute; inset: 0px; z-index: 8; mask-image: linear-gradient(rgba(0, 0, 0, 0) 87.5%, rgb(0, 0, 0) 100%); border-radius: 0px; pointer-events: none; backdrop-filter: blur(10px); will-change: auto;"></div></div><!--/$--></div>
    <section class="footer__inner">
      <Grid isContainer>
        <Grid sm="12" md="12">
          <h2>Get in touch <br> <a href="mailto:hi@frnd.design">hi@frnd.design</a></h2>
        </Grid>
      </Grid>
        
      <Grid isContainer>
        <Grid sm="12" md="6">
          <ul>
              <li><a href="https://x.com/frrrnd" target="_blank">x.com</a></li>
              <li><a href="https://layers.to/fer" target="_blank">Layers</a></li>
              <li><a href="https://linkedin.com/in/frrrnd" target="_blank">Linkedin</a></li>
              <li><a href="mailto:hi@frnd.design" target="_blank">Email</a></li>
          </ul>
        </Grid>
        
        <Grid sm="12" md="6">
          <p>© 2025</p>
        </Grid>
      </Grid>
      
    </section>
        
</footer>
<style>
  .blur-container {
    z-index: 8;
    flex: none;
    height: 200px;
    position: fixed;
    bottom: 0;
    left: 0;
    right: 0;
  }
    .footer {
      width: 100%;  
      padding: var(--spacing-1) 0 calc(var(--spacing-8) + 2rem) 0;
      color: hsla(var(--body-text-color), .5);

      h2 {
        font-size: var(--font-size-h1);
        font-weight: 450;

        a {
          color: hsla(var(--body-text-color), 1);
        }
      }

      .grid-container {
        margin-bottom: var(--spacing-2);
      }
    }

    .footer__inner {
        ul {
            display: flex;
            flex-direction: row;
            gap: var(--spacing-2);
            list-style-type: none;
            padding-left: 0;
            margin: 0;
        }

        a {
            color: hsla(var(--body-text-color), 0.6);
        }
        
        p {
          width: 100%;
          text-align: right;
        }
    }
</style>

<script>
// Objeto global para armazenar todos os intervalos ativos
window.shuffleIntervals = {};

// Função para limpar completamente todos os efeitos shuffle ativos
function cleanupAllShuffleEffects() {
  // Limpar todos os intervalos registrados
  Object.keys(window.shuffleIntervals).forEach(id => {
    clearInterval(window.shuffleIntervals[id]);
    delete window.shuffleIntervals[id];
  });
  
  // Restaurar todos os textos originais para elementos ativos
  document.querySelectorAll(".shuffle").forEach(el => {
    if (el.dataset.originalText) {
      el.textContent = el.dataset.originalText;
    }
    
    // Para elementos com filhos
    if (el.querySelectorAll("[data-original-text]").length > 0) {
      el.querySelectorAll("[data-original-text]").forEach(child => {
        child.textContent = child.dataset.originalText;
      });
    }
  });
}

// Função principal de inicialização com proteção contra duplicação
function initializeShuffle() {
  // Limpar completamente qualquer efeito ativo antes de reinicializar
  cleanupAllShuffleEffects();
  
  // Remover todos os event listeners antigos usando a técnica de clonagem
  document.querySelectorAll(".shuffle").forEach(shuffledEl => {
    const clone = shuffledEl.cloneNode(true);
    if (shuffledEl.parentNode) {
      shuffledEl.parentNode.replaceChild(clone, shuffledEl);
    }
  });
  
  // Agora reinicializar com os elementos clonados/limpos
  let shuffledEls = document.querySelectorAll(".shuffle");
  let duration = 20;
  let framesMax = 7;
  
  shuffledEls.forEach((shuffledEl) => {
    // Array para armazenar todos os elementos filhos com texto
    const childElements = [];
    const textOriginals = [];
    
    // Se o elemento tem filhos, vamos usar todos eles
    if (shuffledEl.children.length > 0) {
      // Pegar todos os elementos filhos que contêm texto
      Array.from(shuffledEl.children).forEach(child => {
        if (child.textContent.trim() !== '') {
          childElements.push(child);
          textOriginals.push(child.textContent);
          // Armazenar o texto original como atributo de dados
          child.dataset.originalText = child.textContent;
        }
      });
    }
    // Se não tiver filhos ou nenhum filho com texto, usamos o próprio elemento
    if (childElements.length === 0) {
      childElements.push(shuffledEl);
      textOriginals.push(shuffledEl.textContent);
      // Armazenar o texto original como atributo de dados
      shuffledEl.dataset.originalText = shuffledEl.textContent;
    }
    
    // Associamos um identificador único ao elemento para rastreamento
    const uniqueId = 'shuffle-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9);
    shuffledEl.dataset.shuffleId = uniqueId;
    
    // Adicionar evento hover
    shuffledEl.addEventListener("mouseover", function() {
      // Limpar qualquer intervalo anterior associado a este elemento
      if (window.shuffleIntervals[uniqueId]) {
        clearInterval(window.shuffleIntervals[uniqueId]);
        delete window.shuffleIntervals[uniqueId];
      }
      
      let frame = 0;
      const inter = setInterval(() => {
        if(frame < framesMax) {
          childElements.forEach((el) => {
            let chars = el.textContent.split("");
            let shuffled = shuffleArr(chars);
            el.textContent = shuffled.join("");
          });
          frame++;
        } else {
          // Limpar intervalo e restaurar texto original quando terminar
          clearInterval(inter);
          childElements.forEach((el, i) => {
            el.textContent = textOriginals[i];
          });
          // Remover do registro de intervalos ativos
          delete window.shuffleIntervals[uniqueId];
        }
      }, duration);
      
      // Registrar o intervalo
      window.shuffleIntervals[uniqueId] = inter;
    });
    
    // Parar o efeito e restaurar todos os textos originais no mouseleave
    shuffledEl.addEventListener("mouseleave", function() {
      if (window.shuffleIntervals[uniqueId]) {
        clearInterval(window.shuffleIntervals[uniqueId]);
        delete window.shuffleIntervals[uniqueId];
      }
      
      // Restaurar texto original imediatamente
      childElements.forEach((el, i) => {
        el.textContent = textOriginals[i];
      });
    });
  });
}

function shuffleArr(arr) {
  return arr.reduce(
    ([a, b]) => (
      b.push(...a.splice((Math.random() * a.length) | 0, 1)), [a, b]
    ),
    [[...arr], []]
  )[1];
}

// Lidar com navegação no Astro e SPA de forma robusta
function handleNavigationEvents() {
  // Limpeza antes de qualquer troca de página
  document.addEventListener('astro:before-swap', () => {
    cleanupAllShuffleEffects();
  });

  // Reinicializar após troca de página
  document.addEventListener('astro:after-swap', () => {
    // Pequeno timeout para garantir que DOM esteja estável
    setTimeout(() => {
      initializeShuffle();
    }, 100);
  });
  
  // Hooks de navegação adicionais para outros frameworks
  window.addEventListener('popstate', () => {
    cleanupAllShuffleEffects();
    // Pequeno timeout para garantir que DOM esteja estável
    setTimeout(() => {
      initializeShuffle();
    }, 100);
  });
  
  // Para detecção de navegação em SPAs que usam History API
  const originalPushState = window.history.pushState;
  window.history.pushState = function() {
    originalPushState.apply(this, arguments);
    cleanupAllShuffleEffects();
    setTimeout(() => {
      initializeShuffle();
    }, 100);
  };
}

// Inicialização
document.addEventListener('DOMContentLoaded', () => {
  // Configurar handlers de navegação
  handleNavigationEvents();
  
  // Inicialização inicial
  initializeShuffle();
});

// Garantir que o código seja executado mesmo se o evento DOMContentLoaded já tiver ocorrido
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', () => {
    handleNavigationEvents();
    initializeShuffle();
  });
} else {
  handleNavigationEvents();
  initializeShuffle();
}

// Disponibilizar globalmente
window.initializeShuffle = initializeShuffle;
window.cleanupAllShuffleEffects = cleanupAllShuffleEffects;

// Animação

// Configuração do Intersection Observer para animações no scroll
const observerConfig = {
  root: null,
  rootMargin: '0px 0px -100px 0px', // Ativa 100px antes do elemento entrar na viewport
  threshold: 0.1 // Ativa quando 10% do elemento estiver visível
};

let observer = null;

// Função para observar elementos
function observeElements() {
  // Desconecta observer anterior se existir
  if (observer) {
    observer.disconnect();
  }

  // Seleciona todos os elementos com data-anima
  const elements = document.querySelectorAll('[data-anima]');
  
  if (elements.length === 0) return;

  // Cria o Intersection Observer
  observer = new IntersectionObserver((entries) => {
    entries.forEach(entry => {
      // Quando o elemento entra na viewport
      if (entry.isIntersecting) {
        // Adiciona a classe 'animate'
        entry.target.classList.add('animate');
        
        // Para de observar o elemento (animação acontece apenas uma vez)
        observer.unobserve(entry.target);
      }
    });
  }, observerConfig);

  // Observa cada elemento
  elements.forEach(element => {
    // Só observa se ainda não tem a classe animate
    if (!element.classList.contains('animate')) {
      observer.observe(element);
    }
  });
}

// Inicializa quando o DOM carregar
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', observeElements);
} else {
  observeElements();
}

// Suporte para transições do Astro (View Transitions)
document.addEventListener('astro:page-load', observeElements);

// Limpa o observer quando a página for trocar (opcional, para performance)
document.addEventListener('astro:before-preparation', () => {
  if (observer) {
    observer.disconnect();
  }
});

</script>